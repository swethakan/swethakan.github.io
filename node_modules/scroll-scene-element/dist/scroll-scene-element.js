const e=new Map,t=new WeakMap;let s=0,n=!1;function o(o,r){let f=e.get(r);f||(f=function(e){return new IntersectionObserver(e=>{const o=window.pageYOffset;n=o>s,s=o;for(const s of e){const e=s.target,o=s.boundingClientRect,r=e.offset,f=s.isIntersecting;if(e.progress){let s=t.get(e);s||(s=i(e),t.set(e,s)),f?s.on():s.off()}e.dispatchEvent(new CustomEvent("scroll-scene-"+(f?"enter":"exit"),{bubbles:!0,detail:{bounds:o,isScrollingDown:n,element:e,offset:r}}))}},{rootMargin:`${-100*(1-e)}% 0px ${-100*e}%`})}(r),e.set(r,f)),f.observe(o)}function r(t,s){const n=e.get(s);n&&n.unobserve(t)}function i(e){function t(){const t=e.getBoundingClientRect(),s=e.offset,n=t.top,o=Math.max(0,Math.min((window.innerHeight*(1-s)-n)/(t.bottom-n),1));e.dispatchEvent(new CustomEvent("scroll-scene-progress",{bubbles:!0,detail:{bounds:t,element:e,progress:o,offset:s}}))}return{on(){t(),window.addEventListener("scroll",t,!1)},off(){window.removeEventListener("scroll",t,!1)}}}class f extends HTMLElement{connectedCallback(){o(this,this.offset)}disconnectedCallback(){r(this,this.offset)}attributeChangedCallback(e,t){if("offset"===e){const e=Number.parseFloat(t)||.5;e!==this.offset&&(r(this,e),o(this,this.offset))}}static get observedAttributes(){return["offset","progress"]}get offset(){return Number.parseFloat(this.getAttribute("offset"))||.5}set offset(e){this.setAttribute("offset",e.toString())}get progress(){return this.hasAttribute("progress")}set progress(e){e?this.setAttribute("progress",""):this.removeAttribute("progress")}}window.customElements.get("scroll-scene")||(window.ScrollSceneElement=f,window.customElements.define("scroll-scene",f));export{f as default};
//# sourceMappingURL=scroll-scene-element.js.map
