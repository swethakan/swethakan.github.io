{"version":3,"file":"scroll-scene-element.js","sources":["../src/scroll-scene-element.ts"],"sourcesContent":["const DEFAULT_OFFSET = 0.5;\nconst offsetObservers = new Map<number, IntersectionObserver>();\ntype ProgressCommands = { on: () => void; off: () => void };\nconst progressListeners = new WeakMap<ScrollSceneElement, ProgressCommands>();\n\nlet previousScrollDepth = 0;\nlet isScrollingDown = false;\n\nfunction createOffsetObserver(offset: number) {\n\treturn new IntersectionObserver(\n\t\t(entries) => {\n\t\t\tconst scrollDepth = window.pageYOffset;\n\t\t\tisScrollingDown = scrollDepth > previousScrollDepth;\n\t\t\tpreviousScrollDepth = scrollDepth;\n\n\t\t\tfor (const entry of entries) {\n\t\t\t\tconst element = entry.target as ScrollSceneElement;\n\t\t\t\tconst bounds = entry.boundingClientRect;\n\t\t\t\tconst offset = element.offset;\n\t\t\t\tconst progress = element.progress;\n\t\t\t\tconst isIntersecting = entry.isIntersecting;\n\n\t\t\t\tif (progress) {\n\t\t\t\t\tlet commands = progressListeners.get(element);\n\n\t\t\t\t\tif (!commands) {\n\t\t\t\t\t\tcommands = observeProgress(element);\n\t\t\t\t\t\tprogressListeners.set(element, commands);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isIntersecting) {\n\t\t\t\t\t\tcommands.on();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommands.off();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telement.dispatchEvent(\n\t\t\t\t\tnew CustomEvent(`scroll-scene-${isIntersecting ? 'enter' : 'exit'}`, {\n\t\t\t\t\t\tbubbles: true,\n\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\tbounds,\n\t\t\t\t\t\t\tisScrollingDown,\n\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t\toffset,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\trootMargin: `${-100 * (1 - offset)}% 0px ${-100 * offset}%`,\n\t\t},\n\t);\n}\n\nfunction connectToObserver(element: ScrollSceneElement, offset: number) {\n\tlet observer = offsetObservers.get(offset);\n\n\tif (!observer) {\n\t\tobserver = createOffsetObserver(offset);\n\t\toffsetObservers.set(offset, observer);\n\t}\n\n\tobserver.observe(element);\n}\n\nfunction disconnectFromObserver(element: ScrollSceneElement, offset: number) {\n\tconst observer = offsetObservers.get(offset);\n\n\t// Is there a race-condition scenario where this does not exist? Not sure.\n\tif (observer) {\n\t\tobserver.unobserve(element);\n\t}\n}\n\nfunction observeProgress(element: ScrollSceneElement): ProgressCommands {\n\t/**\n\t * Called on each scroll event.\n\t */\n\tfunction scroll() {\n\t\tconst bounds = element.getBoundingClientRect();\n\t\tconst offset = element.offset;\n\t\tconst top = bounds.top;\n\t\tconst bottom = bounds.bottom;\n\t\t// ensure progress is never less than 0 or greater than 1\n\t\tconst progress = Math.max(\n\t\t\t0,\n\t\t\tMath.min((window.innerHeight * (1 - offset) - top) / (bottom - top), 1),\n\t\t);\n\n\t\telement.dispatchEvent(\n\t\t\tnew CustomEvent('scroll-scene-progress', {\n\t\t\t\tbubbles: true,\n\t\t\t\tdetail: {\n\t\t\t\t\tbounds,\n\t\t\t\t\telement,\n\t\t\t\t\tprogress,\n\t\t\t\t\toffset,\n\t\t\t\t},\n\t\t\t}),\n\t\t);\n\t}\n\n\treturn {\n\t\ton() {\n\t\t\t// initial hit\n\t\t\tscroll();\n\t\t\twindow.addEventListener('scroll', scroll, false);\n\t\t},\n\t\toff() {\n\t\t\twindow.removeEventListener('scroll', scroll, false);\n\t\t},\n\t};\n}\n\nclass ScrollSceneElement extends HTMLElement {\n\tconnectedCallback() {\n\t\tconnectToObserver(this, this.offset);\n\t}\n\n\tdisconnectedCallback() {\n\t\tdisconnectFromObserver(this, this.offset);\n\t}\n\n\tattributeChangedCallback(attribute: string, oldValue: string) {\n\t\tif (attribute === 'offset') {\n\t\t\tconst previousOffset = Number.parseFloat(oldValue) || DEFAULT_OFFSET;\n\n\t\t\tif (previousOffset !== this.offset) {\n\t\t\t\tdisconnectFromObserver(this, previousOffset);\n\t\t\t\tconnectToObserver(this, this.offset);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic get observedAttributes() {\n\t\treturn ['offset', 'progress'];\n\t}\n\n\tget offset() {\n\t\treturn Number.parseFloat(this.getAttribute('offset')) || DEFAULT_OFFSET;\n\t}\n\n\tset offset(value: number) {\n\t\tthis.setAttribute('offset', value.toString());\n\t}\n\n\tget progress() {\n\t\treturn this.hasAttribute('progress');\n\t}\n\n\tset progress(value: boolean) {\n\t\tif (value) {\n\t\t\tthis.setAttribute('progress', '');\n\t\t} else {\n\t\t\tthis.removeAttribute('progress');\n\t\t}\n\t}\n}\n\ndeclare global {\n\tinterface Window {\n\t\tScrollSceneElement: typeof ScrollSceneElement;\n\t}\n}\n\nexport default ScrollSceneElement;\n\nif (!window.customElements.get('scroll-scene')) {\n\twindow.ScrollSceneElement = ScrollSceneElement;\n\twindow.customElements.define('scroll-scene', ScrollSceneElement);\n}\n"],"names":["offsetObservers","Map","progressListeners","WeakMap","previousScrollDepth","isScrollingDown","connectToObserver","element","offset","observer","get","IntersectionObserver","entries","scrollDepth","window","pageYOffset","entry","target","bounds","boundingClientRect","isIntersecting","progress","commands","observeProgress","set","on","off","dispatchEvent","CustomEvent","bubbles","detail","rootMargin","createOffsetObserver","observe","disconnectFromObserver","unobserve","scroll","getBoundingClientRect","top","Math","max","min","innerHeight","bottom","addEventListener","removeEventListener","ScrollSceneElement","HTMLElement","connectedCallback","this","disconnectedCallback","attributeChangedCallback","attribute","oldValue","previousOffset","Number","parseFloat","observedAttributes","getAttribute","value","setAttribute","toString","hasAttribute","removeAttribute","customElements","define"],"mappings":"AAAA,MACMA,EAAkB,IAAIC,IAEtBC,EAAoB,IAAIC,QAE9B,IAAIC,EAAsB,EACtBC,GAAkB,EAkDtB,SAASC,EAAkBC,EAA6BC,GACvD,IAAIC,EAAWT,EAAgBU,IAAIF,GAE9BC,IACJA,EApDF,SAA8BD,GAC7B,OAAWG,IAAAA,qBACTC,IACA,MAAMC,EAAcC,OAAOC,YAC3BV,EAAkBQ,EAAcT,EAChCA,EAAsBS,EAEtB,IAAK,MAAMG,KAASJ,EAAS,CAC5B,MAAML,EAAUS,EAAMC,OAChBC,EAASF,EAAMG,mBACfX,EAASD,EAAQC,OAEjBY,EAAiBJ,EAAMI,eAE7B,GAHiBb,EAAQc,SAGX,CACb,IAAIC,EAAWpB,EAAkBQ,IAAIH,GAEhCe,IACJA,EAAWC,EAAgBhB,GAC3BL,EAAkBsB,IAAIjB,EAASe,IAG5BF,EACHE,EAASG,KAETH,EAASI,MAIXnB,EAAQoB,cACP,IAAIC,YAA4B,iBAAAR,EAAiB,QAAU,QAAU,CACpES,SAAS,EACTC,OAAQ,CACPZ,OAAAA,EACAb,gBAAAA,EACAE,QAAAA,EACAC,OAAAA,QAML,CACCuB,WAAY,IAAI,KAAO,EAAIvB,YAAiB,IAAMA,OASxCwB,CAAqBxB,GAChCR,EAAgBwB,IAAIhB,EAAQC,IAG7BA,EAASwB,QAAQ1B,GAGlB,SAAS2B,EAAuB3B,EAA6BC,GAC5D,MAAMC,EAAWT,EAAgBU,IAAIF,GAGjCC,GACHA,EAAS0B,UAAU5B,GAIrB,SAASgB,EAAgBhB,GAIxB,SAAS6B,IACR,MAAMlB,EAASX,EAAQ8B,wBACjB7B,EAASD,EAAQC,OACjB8B,EAAMpB,EAAOoB,IAGbjB,EAAWkB,KAAKC,IACrB,EACAD,KAAKE,KAAK3B,OAAO4B,aAAe,EAAIlC,GAAU8B,IAJhCpB,EAAOyB,OAI0CL,GAAM,IAGtE/B,EAAQoB,cACP,IAAIC,YAAY,wBAAyB,CACxCC,SAAS,EACTC,OAAQ,CACPZ,OAAAA,EACAX,QAAAA,EACAc,SAAAA,EACAb,OAAAA,MAMJ,MAAO,CACNiB,KAECW,IACAtB,OAAO8B,iBAAiB,SAAUR,GAAQ,IAE3CV,MACCZ,OAAO+B,oBAAoB,SAAUT,GAAQ,KAKhD,MAAMU,UAA2BC,YAChCC,oBACC1C,EAAkB2C,KAAMA,KAAKzC,QAG9B0C,uBACChB,EAAuBe,KAAMA,KAAKzC,QAGnC2C,yBAAyBC,EAAmBC,GAC3C,GAAkB,WAAdD,EAAwB,CAC3B,MAAME,EAAiBC,OAAOC,WAAWH,IA/HrB,GAiIhBC,IAAmBL,KAAKzC,SAC3B0B,EAAuBe,KAAMK,GAC7BhD,EAAkB2C,KAAMA,KAAKzC,UAKrBiD,gCACV,MAAO,CAAC,SAAU,YAGfjD,aACH,OAAO+C,OAAOC,WAAWP,KAAKS,aAAa,YA7ItB,GAgJlBlD,WAAOmD,GACVV,KAAKW,aAAa,SAAUD,EAAME,YAG/BxC,eACH,OAAO4B,KAAKa,aAAa,YAGtBzC,aAASsC,GACRA,EACHV,KAAKW,aAAa,WAAY,IAE9BX,KAAKc,gBAAgB,aAanBjD,OAAOkD,eAAetD,IAAI,kBAC9BI,OAAOgC,mBAAqBA,EAC5BhC,OAAOkD,eAAeC,OAAO,eAAgBnB"}